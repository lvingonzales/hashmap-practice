(()=>{"use strict";var __webpack_modules__={72:()=>{eval("\n;// ./src/LinkedList.js\nclass LinkedList {\r\n    constructor () {\r\n        this.list = [];\r\n    }\r\n\r\n    append(value) {\r\n        let newNode = new Node;\r\n        newNode.value = value;\r\n\r\n        // Changing the nextNode of the previous tail\r\n        if (this.size() >= 2) {\r\n            this.tail().nextNode = newNode;\r\n        }\r\n\r\n        this.list.push(newNode);  \r\n    }\r\n\r\n    prepend (value) {\r\n        let newNode = new Node;\r\n        newNode = {value:value, nextNode: this.list[0]};\r\n        this.list.unshift(newNode);\r\n    }\r\n\r\n    size () {\r\n        return this.list.length;\r\n    }\r\n\r\n    head () {\r\n        return this.list[0];\r\n    }\r\n\r\n    tail() {\r\n        return this.list[this.size() - 1];\r\n    }\r\n\r\n    at(index) {\r\n        if(index > (this.size() - 1) || index < 0) {return console.error('Index not within List!');}\r\n        return this.list[index];\r\n    }\r\n\r\n    pop() {\r\n        if (!this.size){return console.error('List Empty!');}\r\n        this.list.pop();\r\n        this.tail().nextNode = null;\r\n    }\r\n\r\n    contains(value) {\r\n        const values = this.list.map(nodes => nodes);\r\n        if (!values.includes(value)) {return console.error ('Node not found!');}\r\n        return values.includes(value);\r\n    }\r\n\r\n    find(value) {\r\n        const values = this.list.map(nodes => nodes);\r\n        if (this.contains(value)) {return values.findIndex((foo) => foo === value);};\r\n    }\r\n\r\n    toString() {\r\n        let string;\r\n        const values = this.list.map(nodes => nodes.value);\r\n        for (let i = 0; i <= this.size(); i++) {\r\n            if (i === 0) {\r\n                string = `( key:${values[i].key}, value:${values[i].value} )`;\r\n                continue;\r\n            }\r\n\r\n            if (!values[i]){\r\n                string = string + ` ->  null `;\r\n                continue;\r\n            }\r\n\r\n            string = string + ` -> ( key:${values[i].key}, value:${values[i].value} )`;\r\n        }\r\n\r\n        return string;\r\n    }\r\n\r\n    insertAt(value, index){\r\n        let newNode = new Node();\r\n        newNode.value = value;\r\n\r\n        if(this.list[index]) {\r\n            newNode.nextNode = this.list[index];\r\n        }\r\n\r\n        this.list.splice(index, 0, newNode);\r\n\r\n        this.list[index-1].nextNode = newNode;\r\n        \r\n    }\r\n\r\n    removeAt(index){\r\n        this.list.splice(index, 1);\r\n        \r\n        if (index > 0) {\r\n            this.list[index-1].nextNode = this.list[index];\r\n            if (!this.list[index-1].nextNode){this.list[index-1].nextNode = null;}\r\n        }   \r\n    }\r\n\r\n    findByKey(key) {\r\n        let matchingKey = this.list.find(node => node.value.key === key);\r\n        return matchingKey;\r\n    }\r\n}\r\n\r\nclass Node {\r\n    constructor () {\r\n        this.value = null;\r\n        this.nextNode = null;\r\n    }\r\n}\r\n\r\n\r\n\n;// ./src/HashMap.js\n\r\n\r\nclass HashMap {\r\n    constructor() {\r\n        this.capacity = 16;\r\n        this.loadFactor = .75;\r\n        this.buckets = new Array (this.capacity);\r\n    }\r\n\r\n    set(key, value) {\r\n        let keyCode = hash(key);\r\n        let newNode = new HashMap_Node(key, value);\r\n        let bucket = keyCode % 16;\r\n        indexCheck(bucket, this.buckets);\r\n\r\n        let matchingNode = hashSearch(this, key);\r\n\r\n        if (matchingNode.node !== null) {\r\n            matchingNode.node.value.value = newNode.value;\r\n        } else if(this.buckets[bucket]) {\r\n            this.buckets[bucket].append(newNode);\r\n        } else {\r\n            // Creating a new Linked List for an empty bucket\r\n            let newLinkedList = new LinkedList();\r\n            newLinkedList.append(newNode);\r\n            this.buckets[bucket] = newLinkedList;\r\n        }\r\n\r\n        if (this.length() >= (this.loadFactor * this.capacity)) {\r\n            console.log (`expanding HashMap`);\r\n            let newBuckets = new Array (this.capacity * 2);\r\n            for (let i = 0; i < this.buckets.length; i++) {\r\n                newBuckets[i] = this.buckets[i];\r\n            }\r\n            this.buckets = newBuckets;\r\n            this.capacity = newBuckets.length;\r\n        }\r\n    }\r\n\r\n    get(key){\r\n        let matchingNode = hashSearch(this, key);\r\n        if (matchingNode.node !== null) {return matchingNode.value.value}\r\n    }\r\n\r\n    has(key) {\r\n        let matchingNode = hashSearch(this, key);\r\n        if (matchingNode.node === null) {return false}\r\n        return true;\r\n    }\r\n\r\n    remove(key) {\r\n        let matchingNode = hashSearch(this, key);\r\n        if (matchingNode.node !== null) {\r\n            let index = matchingNode.matchingBucket.find(matchingNode.node);\r\n\r\n            matchingNode.matchingBucket.removeAt(index);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    length() {\r\n        let size = 0;\r\n        let existingNodes = this.buckets.filter(node => node !== undefined);\r\n        existingNodes.forEach(linkedList => {\r\n            size = size + linkedList.size();\r\n        });\r\n        return size;\r\n    }\r\n\r\n    clear() {\r\n        this.buckets = new Array (this.capacity);\r\n    }\r\n    \r\n    keys() {\r\n        let keys = [];\r\n        let existingNodes = this.buckets.filter(node => node !== undefined);\r\n        existingNodes.forEach(linkedList => {\r\n            linkedList.list.forEach(node => {\r\n                keys.push(node.value.key);\r\n            })\r\n        });\r\n\r\n        return keys;\r\n    }\r\n\r\n    values() {\r\n        let values = [];\r\n        let existingNodes = this.buckets.filter(node => node !== undefined);\r\n        existingNodes.forEach(linkedList => {\r\n            linkedList.list.forEach(node => {\r\n                values.push(node.value.value);\r\n            })\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    entries() {\r\n        let entries = [];\r\n        let existingNodes = this.buckets.filter(node => node !== undefined);\r\n        existingNodes.forEach(linkedList => {\r\n            linkedList.list.forEach(node => {\r\n                entries.push(node.value);\r\n            })\r\n        });\r\n\r\n        return entries;\r\n    }\r\n}\r\n\r\nclass HashMap_Node {\r\n    constructor(key, value){\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n\r\nfunction indexCheck (index, buckets) {\r\n    if (index < 0 || index >= buckets.length) {\r\n        throw new Error(\"Trying to access index out of bounds\");\r\n      }\r\n}\r\n\r\nfunction hashSearch(hashmap, key) {\r\n    // Check for a already existing node\r\n    let node = null;\r\n\r\n    let existingNodes = hashmap.buckets.filter(node => node !== undefined);\r\n    let matchingBucket = existingNodes.find(node => node.list.find(subnode => hash(subnode.value.key) === hash(key)));\r\n    if (matchingBucket !== undefined) {\r\n        node = matchingBucket.findByKey(key);\r\n        if (node === undefined) {\r\n            node = null;\r\n        }\r\n    } \r\n    return {node, matchingBucket};\r\n}\r\n\r\nfunction hash(key) {\r\n    let hashCode= 0;\r\n\r\n    const primeNumber = 31;\r\n    for (let i = 0; i < key.length; i++) {\r\n        hashCode = (primeNumber * hashCode + key.charCodeAt(i)) % 16;\r\n    }\r\n\r\n    return hashCode;\r\n}\r\n\r\n\r\n\n;// ./src/index.js\n\r\n\r\n//import \"./style.css\";\r\nconst test = new HashMap();\r\n\r\ntest.set('apple', 'red')\r\ntest.set('banana', 'yellow')\r\ntest.set('carrot', 'orange')\r\ntest.set('dog', 'brown')\r\ntest.set('elephant', 'gray')\r\ntest.set('frog', 'green')\r\ntest.set('grape', 'purple')\r\ntest.set('hat', 'black')\r\ntest.set('ice cream', 'white')\r\ntest.set('jacket', 'blue')\r\ntest.set('kite', 'pink')\r\ntest.set('lion', 'golden')\r\ntest.set('moon', 'silver')\r\n\r\n\r\nconsole.log(test.remove('dog'));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLGtDQUFrQyxjQUFjLFVBQVUsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyxVQUFVLGlCQUFpQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0I7OztBQ2pIeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQjs7O0FDdEpzQjtBQUNNO0FBQzdDO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnBhY2stdGVtcGxhdGUvLi9zcmMvTGlua2VkTGlzdC5qcz81NTc3Iiwid2VicGFjazovL3dlYnBhY2stdGVtcGxhdGUvLi9zcmMvSGFzaE1hcC5qcz8yM2IyIiwid2VicGFjazovL3dlYnBhY2stdGVtcGxhdGUvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBMaW5rZWRMaXN0IHtcclxuICAgIGNvbnN0cnVjdG9yICgpIHtcclxuICAgICAgICB0aGlzLmxpc3QgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhcHBlbmQodmFsdWUpIHtcclxuICAgICAgICBsZXQgbmV3Tm9kZSA9IG5ldyBOb2RlO1xyXG4gICAgICAgIG5ld05vZGUudmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIG5leHROb2RlIG9mIHRoZSBwcmV2aW91cyB0YWlsXHJcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpID49IDIpIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsKCkubmV4dE5vZGUgPSBuZXdOb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5saXN0LnB1c2gobmV3Tm9kZSk7ICBcclxuICAgIH1cclxuXHJcbiAgICBwcmVwZW5kICh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBuZXdOb2RlID0gbmV3IE5vZGU7XHJcbiAgICAgICAgbmV3Tm9kZSA9IHt2YWx1ZTp2YWx1ZSwgbmV4dE5vZGU6IHRoaXMubGlzdFswXX07XHJcbiAgICAgICAgdGhpcy5saXN0LnVuc2hpZnQobmV3Tm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2l6ZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaGVhZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFswXTtcclxuICAgIH1cclxuXHJcbiAgICB0YWlsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RbdGhpcy5zaXplKCkgLSAxXTtcclxuICAgIH1cclxuXHJcbiAgICBhdChpbmRleCkge1xyXG4gICAgICAgIGlmKGluZGV4ID4gKHRoaXMuc2l6ZSgpIC0gMSkgfHwgaW5kZXggPCAwKSB7cmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0luZGV4IG5vdCB3aXRoaW4gTGlzdCEnKTt9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFtpbmRleF07XHJcbiAgICB9XHJcblxyXG4gICAgcG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zaXplKXtyZXR1cm4gY29uc29sZS5lcnJvcignTGlzdCBFbXB0eSEnKTt9XHJcbiAgICAgICAgdGhpcy5saXN0LnBvcCgpO1xyXG4gICAgICAgIHRoaXMudGFpbCgpLm5leHROb2RlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWlucyh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubGlzdC5tYXAobm9kZXMgPT4gbm9kZXMpO1xyXG4gICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge3JldHVybiBjb25zb2xlLmVycm9yICgnTm9kZSBub3QgZm91bmQhJyk7fVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXMuaW5jbHVkZXModmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmQodmFsdWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmxpc3QubWFwKG5vZGVzID0+IG5vZGVzKTtcclxuICAgICAgICBpZiAodGhpcy5jb250YWlucyh2YWx1ZSkpIHtyZXR1cm4gdmFsdWVzLmZpbmRJbmRleCgoZm9vKSA9PiBmb28gPT09IHZhbHVlKTt9O1xyXG4gICAgfVxyXG5cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBzdHJpbmc7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5saXN0Lm1hcChub2RlcyA9PiBub2Rlcy52YWx1ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5zaXplKCk7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gYCgga2V5OiR7dmFsdWVzW2ldLmtleX0sIHZhbHVlOiR7dmFsdWVzW2ldLnZhbHVlfSApYDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXZhbHVlc1tpXSl7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcgKyBgIC0+ICBudWxsIGA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nICsgYCAtPiAoIGtleToke3ZhbHVlc1tpXS5rZXl9LCB2YWx1ZToke3ZhbHVlc1tpXS52YWx1ZX0gKWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydEF0KHZhbHVlLCBpbmRleCl7XHJcbiAgICAgICAgbGV0IG5ld05vZGUgPSBuZXcgTm9kZSgpO1xyXG4gICAgICAgIG5ld05vZGUudmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5saXN0W2luZGV4XSkge1xyXG4gICAgICAgICAgICBuZXdOb2RlLm5leHROb2RlID0gdGhpcy5saXN0W2luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubGlzdC5zcGxpY2UoaW5kZXgsIDAsIG5ld05vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RbaW5kZXgtMV0ubmV4dE5vZGUgPSBuZXdOb2RlO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHJlbW92ZUF0KGluZGV4KXtcclxuICAgICAgICB0aGlzLmxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdFtpbmRleC0xXS5uZXh0Tm9kZSA9IHRoaXMubGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5saXN0W2luZGV4LTFdLm5leHROb2RlKXt0aGlzLmxpc3RbaW5kZXgtMV0ubmV4dE5vZGUgPSBudWxsO31cclxuICAgICAgICB9ICAgXHJcbiAgICB9XHJcblxyXG4gICAgZmluZEJ5S2V5KGtleSkge1xyXG4gICAgICAgIGxldCBtYXRjaGluZ0tleSA9IHRoaXMubGlzdC5maW5kKG5vZGUgPT4gbm9kZS52YWx1ZS5rZXkgPT09IGtleSk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nS2V5O1xyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yICgpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB0aGlzLm5leHROb2RlID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHtMaW5rZWRMaXN0fTtcclxuIiwiaW1wb3J0IHsgTGlua2VkTGlzdCB9IGZyb20gXCIuL0xpbmtlZExpc3QuanNcIjtcclxuXHJcbmNsYXNzIEhhc2hNYXAge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IDE2O1xyXG4gICAgICAgIHRoaXMubG9hZEZhY3RvciA9IC43NTtcclxuICAgICAgICB0aGlzLmJ1Y2tldHMgPSBuZXcgQXJyYXkgKHRoaXMuY2FwYWNpdHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGtleUNvZGUgPSBoYXNoKGtleSk7XHJcbiAgICAgICAgbGV0IG5ld05vZGUgPSBuZXcgTm9kZShrZXksIHZhbHVlKTtcclxuICAgICAgICBsZXQgYnVja2V0ID0ga2V5Q29kZSAlIDE2O1xyXG4gICAgICAgIGluZGV4Q2hlY2soYnVja2V0LCB0aGlzLmJ1Y2tldHMpO1xyXG5cclxuICAgICAgICBsZXQgbWF0Y2hpbmdOb2RlID0gaGFzaFNlYXJjaCh0aGlzLCBrZXkpO1xyXG5cclxuICAgICAgICBpZiAobWF0Y2hpbmdOb2RlLm5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbWF0Y2hpbmdOb2RlLm5vZGUudmFsdWUudmFsdWUgPSBuZXdOb2RlLnZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmJ1Y2tldHNbYnVja2V0XSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHNbYnVja2V0XS5hcHBlbmQobmV3Tm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgYSBuZXcgTGlua2VkIExpc3QgZm9yIGFuIGVtcHR5IGJ1Y2tldFxyXG4gICAgICAgICAgICBsZXQgbmV3TGlua2VkTGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XHJcbiAgICAgICAgICAgIG5ld0xpbmtlZExpc3QuYXBwZW5kKG5ld05vZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHNbYnVja2V0XSA9IG5ld0xpbmtlZExpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZW5ndGgoKSA+PSAodGhpcy5sb2FkRmFjdG9yICogdGhpcy5jYXBhY2l0eSkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cgKGBleHBhbmRpbmcgSGFzaE1hcGApO1xyXG4gICAgICAgICAgICBsZXQgbmV3QnVja2V0cyA9IG5ldyBBcnJheSAodGhpcy5jYXBhY2l0eSAqIDIpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVja2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbmV3QnVja2V0c1tpXSA9IHRoaXMuYnVja2V0c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHMgPSBuZXdCdWNrZXRzO1xyXG4gICAgICAgICAgICB0aGlzLmNhcGFjaXR5ID0gbmV3QnVja2V0cy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldChrZXkpe1xyXG4gICAgICAgIGxldCBtYXRjaGluZ05vZGUgPSBoYXNoU2VhcmNoKHRoaXMsIGtleSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nTm9kZS5ub2RlICE9PSBudWxsKSB7cmV0dXJuIG1hdGNoaW5nTm9kZS52YWx1ZS52YWx1ZX1cclxuICAgIH1cclxuXHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgbGV0IG1hdGNoaW5nTm9kZSA9IGhhc2hTZWFyY2godGhpcywga2V5KTtcclxuICAgICAgICBpZiAobWF0Y2hpbmdOb2RlLm5vZGUgPT09IG51bGwpIHtyZXR1cm4gZmFsc2V9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGxldCBtYXRjaGluZ05vZGUgPSBoYXNoU2VhcmNoKHRoaXMsIGtleSk7XHJcbiAgICAgICAgaWYgKG1hdGNoaW5nTm9kZS5ub2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IG1hdGNoaW5nTm9kZS5tYXRjaGluZ0J1Y2tldC5maW5kKG1hdGNoaW5nTm9kZS5ub2RlKTtcclxuXHJcbiAgICAgICAgICAgIG1hdGNoaW5nTm9kZS5tYXRjaGluZ0J1Y2tldC5yZW1vdmVBdChpbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIGxldCBzaXplID0gMDtcclxuICAgICAgICBsZXQgZXhpc3RpbmdOb2RlcyA9IHRoaXMuYnVja2V0cy5maWx0ZXIobm9kZSA9PiBub2RlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIGV4aXN0aW5nTm9kZXMuZm9yRWFjaChsaW5rZWRMaXN0ID0+IHtcclxuICAgICAgICAgICAgc2l6ZSA9IHNpemUgKyBsaW5rZWRMaXN0LnNpemUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmJ1Y2tldHMgPSBuZXcgQXJyYXkgKHRoaXMuY2FwYWNpdHkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBrZXlzKCkge1xyXG4gICAgICAgIGxldCBrZXlzID0gW107XHJcbiAgICAgICAgbGV0IGV4aXN0aW5nTm9kZXMgPSB0aGlzLmJ1Y2tldHMuZmlsdGVyKG5vZGUgPT4gbm9kZSAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICBleGlzdGluZ05vZGVzLmZvckVhY2gobGlua2VkTGlzdCA9PiB7XHJcbiAgICAgICAgICAgIGxpbmtlZExpc3QubGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKG5vZGUudmFsdWUua2V5KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcblxyXG4gICAgdmFsdWVzKCkge1xyXG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBsZXQgZXhpc3RpbmdOb2RlcyA9IHRoaXMuYnVja2V0cy5maWx0ZXIobm9kZSA9PiBub2RlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgIGV4aXN0aW5nTm9kZXMuZm9yRWFjaChsaW5rZWRMaXN0ID0+IHtcclxuICAgICAgICAgICAgbGlua2VkTGlzdC5saXN0LmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChub2RlLnZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH1cclxuXHJcbiAgICBlbnRyaWVzKCkge1xyXG4gICAgICAgIGxldCBlbnRyaWVzID0gW107XHJcbiAgICAgICAgbGV0IGV4aXN0aW5nTm9kZXMgPSB0aGlzLmJ1Y2tldHMuZmlsdGVyKG5vZGUgPT4gbm9kZSAhPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICBleGlzdGluZ05vZGVzLmZvckVhY2gobGlua2VkTGlzdCA9PiB7XHJcbiAgICAgICAgICAgIGxpbmtlZExpc3QubGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKG5vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZW50cmllcztcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlKXtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluZGV4Q2hlY2sgKGluZGV4LCBidWNrZXRzKSB7XHJcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGJ1Y2tldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xyXG4gICAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc2hTZWFyY2goaGFzaG1hcCwga2V5KSB7XHJcbiAgICAvLyBDaGVjayBmb3IgYSBhbHJlYWR5IGV4aXN0aW5nIG5vZGVcclxuICAgIGxldCBub2RlID0gbnVsbDtcclxuXHJcbiAgICBsZXQgZXhpc3RpbmdOb2RlcyA9IGhhc2htYXAuYnVja2V0cy5maWx0ZXIobm9kZSA9PiBub2RlICE9PSB1bmRlZmluZWQpO1xyXG4gICAgbGV0IG1hdGNoaW5nQnVja2V0ID0gZXhpc3RpbmdOb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5saXN0LmZpbmQoc3Vibm9kZSA9PiBoYXNoKHN1Ym5vZGUudmFsdWUua2V5KSA9PT0gaGFzaChrZXkpKSk7XHJcbiAgICBpZiAobWF0Y2hpbmdCdWNrZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5vZGUgPSBtYXRjaGluZ0J1Y2tldC5maW5kQnlLZXkoa2V5KTtcclxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0gXHJcbiAgICByZXR1cm4ge25vZGUsIG1hdGNoaW5nQnVja2V0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzaChrZXkpIHtcclxuICAgIGxldCBoYXNoQ29kZT0gMDtcclxuXHJcbiAgICBjb25zdCBwcmltZU51bWJlciA9IDMxO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBoYXNoQ29kZSA9IChwcmltZU51bWJlciAqIGhhc2hDb2RlICsga2V5LmNoYXJDb2RlQXQoaSkpICUgMTY7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGhhc2hDb2RlO1xyXG59XHJcblxyXG5leHBvcnQge0hhc2hNYXB9O1xyXG4iLCJpbXBvcnQgeyBIYXNoTWFwIH0gZnJvbSBcIi4vSGFzaE1hcC5qc1wiO1xyXG5pbXBvcnQgeyBMaW5rZWRMaXN0IH0gZnJvbSBcIi4vTGlua2VkTGlzdC5qc1wiO1xyXG4vL2ltcG9ydCBcIi4vc3R5bGUuY3NzXCI7XHJcbmNvbnN0IHRlc3QgPSBuZXcgSGFzaE1hcCgpO1xyXG5cclxudGVzdC5zZXQoJ2FwcGxlJywgJ3JlZCcpXHJcbnRlc3Quc2V0KCdiYW5hbmEnLCAneWVsbG93JylcclxudGVzdC5zZXQoJ2NhcnJvdCcsICdvcmFuZ2UnKVxyXG50ZXN0LnNldCgnZG9nJywgJ2Jyb3duJylcclxudGVzdC5zZXQoJ2VsZXBoYW50JywgJ2dyYXknKVxyXG50ZXN0LnNldCgnZnJvZycsICdncmVlbicpXHJcbnRlc3Quc2V0KCdncmFwZScsICdwdXJwbGUnKVxyXG50ZXN0LnNldCgnaGF0JywgJ2JsYWNrJylcclxudGVzdC5zZXQoJ2ljZSBjcmVhbScsICd3aGl0ZScpXHJcbnRlc3Quc2V0KCdqYWNrZXQnLCAnYmx1ZScpXHJcbnRlc3Quc2V0KCdraXRlJywgJ3BpbmsnKVxyXG50ZXN0LnNldCgnbGlvbicsICdnb2xkZW4nKVxyXG50ZXN0LnNldCgnbW9vbicsICdzaWx2ZXInKVxyXG5cclxuXHJcbmNvbnNvbGUubG9nKHRlc3QucmVtb3ZlKCdkb2cnKSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n")}},__webpack_exports__={};__webpack_modules__[72]()})();